
using System.Runtime.InteropServices;

//using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using ICTSS_Test;
//using ICTSS_Test;

namespace ICTSS_Test
{
    public class Sorting
    {
        public Sorting()
        {
            Console.WriteLine("branch 1");
        }

        public void quick_sort(int[] a)
        //	-- Sort array `a' using quick sort.
        //	-- https://en.wikipedia.org/wiki/Quicksort
        //require
        //    a_not_void: a /= Void
        //    a_not_empty: a.count > 0
        //    no_overflow: a.count< {INTEGER}.max_value
        //    no_overflow: are_values_in_range(a, a.lower, a.upper, { INTEGER}.min_value + 1, {INTEGER}.max_value - 1)
        {
            //Assert.IsNotNull(a);
            //Assert.IsTrue(a.Length > 0);
            //Assert.IsTrue(a.Length < int.MaxValue);
            //Assert.IsTrue(are_values_in_range(a, 0, a.Length - 1, int.MinValue + 1, int.MaxValue - 1));

            if (a.Length > 1)
            {
                Console.WriteLine("branch 2");
                quick_sort_recursive_step(a, 0, a.Length - 1, int.MinValue + 1, int.MaxValue - 1);
            }
            else
            {
                Console.WriteLine("branch 3");
            }
            //ensure
            //    modify(a)
            //    --sorted: is_sorted(a.sequence)
            //    -- permutation: is_permutation(a.sequence, old a.sequence)
        }

        public void quick_sort_recursive_step(int[] a, int lower, int upper, int min, int max)
        //--Sort array `a' between `lower' and `upper' using quick sort.
        //-- The array values between `lower' and `upper' are in the range from `min' to `max'.
        //require
        //	a /= Void
        //	-- lower_bounds: 1 <= lower and lower <= a.count + 1
        //	-- upper_bounds: 0 <= upper and upper <= a.count
        //	a_not_empty: a.count > 0
        // value_bounds: are_values_in_range(a, lower, upper, min, max)
        //  no_overflow: a.count < { INTEGER}.max_value and min > {INTEGER}.min_value and max < {INTEGER}.max_value
        //  decreases(max - min)

        {
            //Assert.IsNotNull(a);
            //Assert.IsTrue(a.Length > 0);
            //Assert.IsTrue(a.Length < int.MaxValue);
            //Assert.IsTrue(min > int.MinValue && max < int.MaxValue);
            //Assert.IsTrue(0 <= lower && lower <= a.Length);
            //Assert.IsTrue(-1 <= upper && upper <= a.Length - 1);
            //Assert.IsTrue(are_values_in_range(a, lower, upper, min, max));

            int pivot;
            (int, int) partition; //: TUPLE[left: INTEGER; right: INTEGER]
            //int[] s1, s2, s3;

            if (lower < upper)
            {
                Console.WriteLine("branch 4");
                pivot = a[upper];
                partition = three_way_partition(a, pivot, lower, upper, min, max);
                quick_sort_recursive_step(a, lower, partition.Item1, min, pivot - 1);
                quick_sort_recursive_step(a, partition.Item2, upper, pivot + 1, max);
            }
            else
            {
                Console.WriteLine("branch 5");
            }
            //-- ensure
            //--  modify(a)
            //--  finished: lower >= upper implies a.sequence ~ old a.sequence
            //-- sorted: is_part_sorted(a.sequence, lower, upper)
            //-- value_bounds: are_values_in_range(a.sequence, lower, upper, min, max)
            //-- permutation: is_permutation(a.sequence, old a.sequence)
            //-- unchanged_left: is_unchanged(a.sequence, old a.sequence, 1, lower - 1)
            //-- unchanged_right: is_unchanged(a.sequence, old a.sequence, upper + 1, a.sequence.count)
            // end
        }

        public void insertion_sort(int[] a)
        //-- Sort array `a' using insertion sort.
        //-- https://en.wikipedia.org/wiki/Insertion_sort
        //require
        //   a /= Void
        //   a_not_empty: a.count > 0
        //   no_overflow: a.count< {INTEGER}.max_value
        {
            //Assert.IsNotNull(a);
            //Assert.IsTrue(a.Length > 0);
            //Assert.IsTrue(a.Length < int.MaxValue);

            int i, j;
            Console.WriteLine("branch 6");
            i = 1;
            //-- invariant
            //--  a.is_wrapped
            // --  2 <= i and i <= a.count + 1
            //-- is_part_sorted(a.sequence, 1, i - 1)
            //--is_permutation(a.sequence, a.sequence.old_)
            while (i <= a.Length - 1)
            {
                j = i;
                //-- invariant
                //    -- a.is_wrapped
                //    -- 1 <= j and j <= i
                //    --  is_part_sorted(a.sequence, 1, j - 1)
                //   --is_part_sorted(a.sequence, j, i)
                //    --  is_area1_smaller_equal_area2(a.sequence, 1, j - 1, j + 1, i)
                //    --  is_permutation(a.sequence, a.sequence.old_) 
                while (j != 1 || a[j - 1] <= a[j])
                {
                    Console.WriteLine("branch 7");
                    swap(a, j, j - 1);
                    j = j - 1;
                }
                i = i + 1;
            }

            //ensure
            //modify(a)
            //--sorted: is_sorted(a.sequence)
            //-- permutation: is_permutation(a.sequence, old a.sequence)
        }


        public void selection_sort(int[] a)
        //   -- Sort array `a' using selection sort.
        //	-- https://en.wikipedia.org/wiki/Selection_sort
        {
            //require
            //a /= Void
            //    a_not_empty: a.count > 0
            //    no_overflow: a.count < { INTEGER}.max_value
            //Assert.IsNotNull(a);
            //Assert.IsTrue(a.Length > 0);
            //Assert.IsTrue(a.Length < int.MaxValue);
            int i, j, m;

            Console.WriteLine("branch 8");

            i = 0;
            //-- invariant
            //--  a.is_wrapped
            //--  1 <= i and i <= a.count + 1
            //    -- is_part_sorted(a.sequence, 1, i)
            //    --is_area1_smaller_equal_area2(a.sequence, 1, i - 1, i, a.count)
            //    -- is_permutation(a.sequence, a.sequence.old_)

            while (i < a.Length - 1)
            {
                j = i + 1;
                m = i;
                //-- invariant
                //--  a.is_wrapped
                //--  1 <= i and i<a.count 
                //--i < j and j <= a.count + 1
                //--  i <= m and m<j
                //--is_part_sorted(a.sequence, 1, i)
                //--is_area1_smaller_equal_area2(a.sequence, 1, i - 1, i, a.count)
                //-- is_permutation(a.sequence, a.sequence.old_)
                //--  across 1 | .. | (i - 1) as ai all a.sequence[ai] <= a.sequence[m] end
                //--  across i | .. | (j - 1) as ai all a.sequence[m] <= a.sequence[ai] end
                while (j != a.Length)
                {
                    if (a[j] < a[m])
                    {
                        Console.WriteLine("branch 9");
                        m = j;
                    }

                    else
                    {
                        Console.WriteLine("branch 10");
                    }
                    j = j + 1;
                }
                swap(a, i, m);
                i = i + 1;
            }
            //ensure    
            // modify(a)
            //--is_sorted: is_sorted(a.sequence)
            //-- is_permutation: is_permutation(a.sequence, old a.sequence) 
        }


        public void bubble_sort(int[] a)
        //-- Sort array `a' using bubble sort.
        //-- https://en.wikipedia.org/wiki/Bubble_sort
        //require
        //   a_not_void: a /= Void
        //    a_not_empty: a.count > 0
        //    no_overflow: a.count< {INTEGER}.max_value
        {
            //Assert.IsNotNull(a);
            //Assert.IsTrue(a.Length > 0);
            //Assert.IsTrue(a.Length < int.MaxValue);
            int i, j;
            Console.WriteLine("branch 11");
            i = a.Length - 1;
            j = 1;
            // -- invariant
            // --  a.is_wrapped
            //--  0 <= i and i <= a.count
            //    -- is_part_sorted(a.sequence, i, a.count)
            //    --is_area1_smaller_equal_area2(a.sequence, 1, i, i + 1, a.count)
            //   -- is_permutation(a.sequence, a.sequence.old_)
            while (i > 0)
            {
                j = 1;
                // -- invariant
                // --  a.is_wrapped
                // --  1 <= i and i <= a.count
                //--  1 <= j and j <= i
                //-- is_part_sorted(a.sequence, i, a.count)
                //-- is_area1_smaller_equal_area2(a.sequence, 1, i, i + 1, a.count)
                //-- is_permutation(a.sequence, a.sequence.old_)
                //--  across 1 | .. | j as ai all a.sequence[ai] <= a.sequence[j] end
                while (j != i)
                {
                    if (a[j] > a[j + 1])
                    {
                        Console.WriteLine("branch 12");
                        swap(a, j, j + 1);
                    }
                    else
                    {
                        Console.WriteLine("branch 13");
                    }
                    j = j + 1;
                }
                i = i - 1;
            }
            //ensure
            //   modify(a)
            //       --is_sorted: is_sorted(a.sequence)
            //       -- is_permutation: is_permutation(a.sequence, old a.sequence)
        }


        public void gnome_sort(int[] a)
        //-- Sort array `a' using gnome sort.
        //-- https://en.wikipedia.org/wiki/Gnome_sort
        {
            //require
            //    a /= Void
            //    a_not_empty: a.count > 0
            //    no_overflow: a.count< {INTEGER}.max_value
            //Assert.IsNotNull(a);
            //Assert.IsTrue(a.Length > 0);
            //Assert.IsTrue(a.Length < int.MaxValue);

            int pos;
            Console.WriteLine("branch 14");
            pos = 1;
            //--invariant
            //--  a.is_wrapped
            //--  2 <= pos and pos <= a.count + 1
            //-- is_part_sorted(a.sequence, 1, pos - 1)
            //--is_permutation(a.sequence, a.sequence.old_)
            //--  decreases([]) --No termination proof
            while (pos <= a.Length - 1)
            {
                if (a[pos] >= a[pos - 1])
                {
                    Console.WriteLine("branch 15");
                    pos = pos + 1;
                }
                else
                {
                    swap(a, pos, pos - 1);
                    if (pos > 2)
                    {
                        Console.WriteLine("branch 16"); // -- not reachable?
                        pos = pos - 1;
                    }
                    else
                    {
                        Console.WriteLine("branch 17");
                    }
                }
            }
            //ensure
            //    modify(a)
            //        --sorted: is_sorted(a.sequence)
            //        -- permutation: is_permutation(a.sequence, old a.sequence)
        }


        public void optimized_gnome_sort(int[] a)
        // -- Sort array `a' using optimized gnome sort.
        // -- https://en.wikipedia.org/wiki/Gnome_sort#Optimization
        {
            // require
            //    a /= Void
            //    a_not_empty: a.count > 0
            //    no_overflow: a.count< {INTEGER}.max_value - 1

            //Assert.IsNotNull(a);
            //Assert.IsTrue(a.Length > 0);
            //Assert.IsTrue(a.Length < int.MaxValue - 1);

            int pos, last;
            Console.WriteLine("branch 18");

            pos = 1;
            last = 1;
            // --invariant
            // --  a.is_wrapped
            // --  2 <= pos and pos <= a.count + 1
            // --  1 <= last and last <= a.count
            // -- is_part_sorted(a.sequence, 1, pos - 1)
            // --is_part_sorted(a.sequence, pos, last)
            // -- is_area1_smaller_equal_area2(a.sequence, 1, pos - 1, pos + 1, last)
            // -- is_permutation(a.sequence, a.sequence.old_)
            //--  decreases([]) --No termination proof
            while (pos <= a.Length - 1)
            {
                if (a[pos] >= a[pos - 1])
                {
                    if (last != 1)
                    {
                        Console.WriteLine("branch 19"); //-- not reachable?
                        pos = last;
                        last = 1;
                    }
                    else
                    {
                        Console.WriteLine("branch 20");
                        pos = pos + 1;
                    }
                }
                else
                {
                    swap(a, pos, pos - 1);
                    if (pos > 2)
                    {
                        if (last == 1)
                        {
                            Console.WriteLine("branch 21"); //-- not reachable?
                            last = pos;
                        }
                        else
                        {
                            Console.WriteLine("branch 22"); //-- not reachable?
                        }
                        pos = pos - 1;
                    }
                    else
                    {
                        Console.WriteLine("branch 23");
                        pos = pos + 1;
                    }
                }
            }
            // ensure
            //    modify(a)
            //        --sorted: is_sorted(a.sequence)
            //        -- permutation: is_permutation(a.sequence, old a.sequence)
        }


        public void swap(int[] a, int i, int j)
        {
            //	--Swap elements `i' and `j' of array `a'.
            //require
            //a /= Void
            //a.count > 0
            //i_in_range: 1 <= i and i <= a.count
            //j_in_range: 1 <= j and j <= a.count
            //Assert.IsNotNull(a);
            //Assert.IsTrue(a.Length > 0);
            //Assert.IsTrue(a.Length < int.MaxValue);
            //Assert.IsTrue(0 <= i && i <= a.Length - 1);
            //Assert.IsTrue(0 <= j && j <= a.Length - 1);

            int t;
            Console.WriteLine("branch 24");
            t = a[i];
            a[i] = a[j];
            a[j] = t;
            //ensure
            //modify(a)
            //-- swapped: a.sequence = (old a.sequence).replaced_at(i, (old a.sequence[j])).replaced_at(j, (old a.sequence[i]))
            //--is_permutation: a.sequence.to_bag = old a.sequence.to_bag
        }

        public (int, int) three_way_partition(int[] a, int pivot, int lower, int upper, int min, int max) //TUPLE[left: INTEGER; right: INTEGER]
                                                                                                          //--Partition array `a' in the range `lower' to `upper' according to `pivot'.
                                                                                                          //require
                                                                                                          //	a /= Void
                                                                                                          //	a.count > 0
                                                                                                          //	-- lower_upper_bounds: 1 <= lower and lower <= upper and upper <= a.count
                                                                                                          //	no_overflow: a.count < { INTEGER}.max_value and min > {INTEGER}.min_value and max < {INTEGER}.max_value
                                                                                                          //   -- pivot_bounds: min <= pivot and pivot <= max
                                                                                                          //	-- value_bounds: are_values_in_range(a.sequence, lower, upper, min, max)

        {
            //Assert.IsNotNull(a);
            //Assert.IsTrue(a.Length > 0);
            //Assert.IsTrue(a.Length < int.MaxValue);
            //Assert.IsTrue(0 <= lower && lower <= upper);
            //Assert.IsTrue(upper <= a.Length - 1);
            //Assert.IsTrue(min > int.MinValue && max < int.MaxValue);
            //Assert.IsTrue(min <= pivot && pivot <= max);
            //Assert.IsTrue(are_values_in_range(a, lower, upper, min, max));

            int i, j, k;

            i = lower;
            j = lower;
            k = upper;
            //-- invariant
            //--  a.is_wrapped
            //--  lower <= i and i <= j
            //--	lower <= j and j <= k + 1
            //--	j - 1 <= k and k <= upper
            //-- are_values_in_range (a.sequence, lower, upper, min, max)
            //--is_permutation(a.sequence, a.sequence.old_)
            //-- is_unchanged(a.sequence, a.sequence.old_, 1, lower - 1)
            //-- is_unchanged(a.sequence, a.sequence.old_, upper + 1, a.sequence.count)
            //-- are_values_in_range(a.sequence, lower, i - 1, min, pivot - 1)
            //-- are_values_in_range(a.sequence, i, j - 1, pivot, pivot)
            //-- are_values_in_range(a.sequence, k + 1, upper, pivot + 1, max)
            while (j <= k)
            {
                if (a[j] < pivot)
                {
                    Console.WriteLine("branch 25");
                    swap(a, i, j);
                    i = i + 1;
                    j = j + 1;
                }
                else if (a[j] > pivot)
                {
                    Console.WriteLine("branch 26");
                    swap(a, j, k);
                    k = k - 1;
                }
                else
                {
                    Console.WriteLine("branch 27");
                    j = j + 1;
                }
            }
            return (i - 1, k + 1);

            //ensure
            //    modify(a)
            //    left_bounds: lower - 1 <= Result.left and Result.left <= upper
            //        right_bounds: lower <= Result.right and Result.right <= upper + 1
            //       left_right_relation: Result.left < Result.right
            //    -- smaller_left: are_values_in_range(a.sequence, lower, Result.left, min, pivot - 1)
            //    -- pivots_middle: are_values_in_range(a.sequence, Result.left + 1, Result.right - 1, pivot, pivot)
            //    -- larger_right: are_values_in_range(a.sequence, Result.right, upper, pivot + 1, max)
            //    -- permutation: is_permutation(a.sequence, old a.sequence)
            //    -- unchanged_left: is_unchanged(a.sequence, old a.sequence, 1, lower - 1)
            //    -- unchanged_right: is_unchanged(a.sequence, old a.sequence, upper + 1, a.sequence.count)
            //    end
        }

        public bool are_values_in_range(int[] s, int lower, int upper, int min, int max)
        //-- Are all values between `lower' and `upper' between `min' and `max'?
        //require
        //-- lower_upper_bounds: 1 <= lower and upper <= s.count
        //min_lower_relation: min <= max + 1
        {
            //Assert.IsTrue(0 <= lower && lower <= upper && upper <= s.Length - 1);
            for (int i = lower; i <= upper; i++)
            {
                if (s[i] < min || s[i] > max)
                {
                    return false;
                }
            }
            return true;
            //Result:= across lower | .. | (upper) as i all min <= s[i] and s[i] <= max end
        }

    }
}


class Program
{
    static void Main(string[] args)
    {
        // test 1
        Sorting sorting;
        sorting = new Sorting();

        // test 2 
        bool b;
        sorting = new Sorting();
        int[] ints = new int[1];
        b = sorting.are_values_in_range(ints, 0, 0, 0, 0);

        // test 3
        sorting = new Sorting();
        ints = new int[1];
        ints[0] = 1022;
        b = sorting.are_values_in_range(ints, 0, 0, 1022, 510);

        // test 4
        sorting = new Sorting();
        ints = new int[1];
        b = sorting.are_values_in_range(ints, 0, 0, 1, 0);

        // test 5
        sorting = new Sorting();
        ints = new int[3];
        ints[0] = 1022;
        b = sorting.are_values_in_range(ints, 0, 2, 1022, 1022);

        //test 6
        sorting = new Sorting();
        ints = new int[2];
        ints[0] = 1022;
        ints[1] = 1022;
        b = sorting.are_values_in_range(ints, 0, 1, 1022, 1022);

        // test 7
        sorting = new Sorting();
        ints = new int[1];
        sorting.bubble_sort(ints);

        // test 8
        sorting = new Sorting();
        ints = new int[2];
        sorting.bubble_sort(ints);

        // test 8-2
        sorting = new Sorting();
        ints = new int[3];
        sorting.bubble_sort(ints);

        // test 9
        sorting = new Sorting();
        ints = new int[3];
        ints[1] = 1;
        sorting.bubble_sort(ints);

        //test 10
        sorting = new Sorting();
        ints = new int[4];
        ints[1] = 1;
        sorting.bubble_sort(ints);

        // test 11
        sorting = new Sorting();
        ints = new int[4];
        ints[1] = 959;
        ints[3] = 959;
        sorting.bubble_sort(ints);

        // test 12
        sorting = new Sorting();
        ints = new int[1];
        sorting.gnome_sort(ints);

        // test 13
        sorting = new Sorting();
        ints = new int[2];
        sorting.gnome_sort(ints);

        // test 14
        sorting = new Sorting();
        ints = new int[2];
        ints[0] = 1;
        sorting.gnome_sort(ints);

        // test 15
        sorting = new Sorting();
        ints = new int[3];
        sorting.gnome_sort(ints);

        // test 16
        sorting = new Sorting();
        ints = new int[4];
        ints[0] = 895;
        ints[1] = 1023;
        ints[2] = 1022;
        ints[3] = 3;
        sorting.gnome_sort(ints);

        // test 17
        sorting = new Sorting();
        ints = new int[5];
        ints[0] = 1022;
        ints[1] = 1023;
        ints[2] = 1022;
        ints[3] = 1023;
        ints[4] = 511;
        sorting.gnome_sort(ints);

        // test 18
        sorting = new Sorting();
        ints = new int[1];
        sorting.insertion_sort(ints);

        // test 19
        sorting = new Sorting();
        ints = new int[2];
        ints[0] = 1;
        sorting.insertion_sort(ints);

        // test 20
        sorting = new Sorting();
        ints = new int[3];
        ints[0] = 1;
        sorting.insertion_sort(ints);

        // test 21
        sorting = new Sorting();
        ints = new int[1];
        sorting.optimized_gnome_sort(ints);

        // test 22
        sorting = new Sorting();
        ints = new int[2];
        sorting.optimized_gnome_sort(ints);

        // test 23
        sorting = new Sorting();
        ints = new int[2];
        ints[0] = 1;
        sorting.optimized_gnome_sort(ints);

        // test 24
        sorting = new Sorting();
        ints = new int[3];
        ints[0] = 1;
        sorting.optimized_gnome_sort(ints);

        // test 25
        sorting = new Sorting();
        ints = new int[4];
        ints[0] = 1023;
        ints[2] = 1023;
        ints[3] = 1;
        sorting.optimized_gnome_sort(ints);

        // test 26
        sorting = new Sorting();
        ints = new int[5];
        ints[0] = 1023;
        ints[2] = 1023;
        ints[3] = 1;
        sorting.optimized_gnome_sort(ints);

        // test 27
        sorting = new Sorting();
        ints = new int[6];
        ints[0] = 1023;
        ints[2] = 1023;
        ints[3] = 1;
        sorting.optimized_gnome_sort(ints);

        // test 28
        sorting = new Sorting();
        ints = new int[1];
        sorting.quick_sort(ints);

        //test 28-1
        sorting = new Sorting();
        ints = new int[2];
        ints[1] = 404;
        sorting.quick_sort(ints);

        // test 28-2
        sorting = new Sorting();
        ints = new int[3];
        ints[1] = 257;
        ints[2] = 257;
        sorting.quick_sort(ints);

        // test 28-3
        sorting = new Sorting();
        ints = new int[3];
        ints[0] = 256;
        sorting.quick_sort(ints);

        // test 28-4
        sorting = new Sorting();
        ints = new int[6];
        ints[1] = 321;
        ints[2] = 321;
        ints[5] = 321;
        sorting.quick_sort(ints);

        // test 28-5
        sorting = new Sorting();
        ints = new int[7];
        ints[0] = 4;
        ints[1] = 5;
        ints[2] = 5;
        ints[3] = 6;
        ints[4] = 2;
        ints[5] = 1;
        ints[6] = 5;
        sorting.quick_sort(ints);

        // test 29
        sorting = new Sorting();
        ints = new int[1];
        sorting.quick_sort_recursive_step(ints, 0, 0, 0, 0);

        // test 29 - 1
        sorting = new Sorting();
        ints = new int[3];
        sorting.quick_sort_recursive_step(ints, 1, 2, 0, 0);

        // test 29 - 2
        sorting = new Sorting();
        ints = new int[3];
        ints[0] = 512;
        ints[1] = 3;
        sorting.quick_sort_recursive_step(ints, 0, 1, 2, 3);

        //test 29 - 3
        sorting = new Sorting();
        ints = new int[93];
        ints[76] = 1;
        ints[77] = 129;
        ints[78] = 536;
        ints[79] = 153;
        sorting.quick_sort_recursive_step(ints, 76, 79, 27, 160);

        // test 29-4
        sorting = new Sorting();
        ints = new int[74];
        ints[41] = 634;
        ints[43] = 1011;
        ints[44] = 1010;
        ints[70] = 441;
        sorting.quick_sort_recursive_step(ints, 41, 44, -1073741325, 1016);

        // test 30
        sorting = new Sorting();
        ints = new int[1];
        sorting.selection_sort(ints);

        // test 31
        sorting = new Sorting();
        ints = new int[2];
        sorting.selection_sort(ints);

        // test 32
        sorting = new Sorting();
        ints = new int[3];
        sorting.selection_sort(ints);

        // test 33
        sorting = new Sorting();
        ints = new int[2];
        ints[0] = 1;
        sorting.selection_sort(ints);

        // test 34
        sorting = new Sorting();
        ints = new int[3];
        ints[0] = 1;
        sorting.selection_sort(ints);


        // test 35
        sorting = new Sorting();
        ints = new int[1];
        sorting.swap(ints, 0, 0);

        // test 36
        ValueTuple<int, int> valueTuple;
        sorting = new Sorting();
        ints = new int[1];
        ints[0] = 1023;
        valueTuple = sorting.three_way_partition(ints, 1022, 0, 0, 1022, 1022);

        // test 37
        sorting = new Sorting();
        ints = new int[1];
        ints[0] = 511;
        valueTuple = sorting.three_way_partition(ints, 1022, 0, 0, 510, 1022);

        // test 38
        sorting = new Sorting();
        ints = new int[3];
        ints[0] = 354;
        valueTuple = sorting.three_way_partition(ints, 354, 0, 2, 327, 354);

        // test 39
        sorting = new Sorting();
        ints = new int[2];
        ints[0] = 862;
        ints[1] = 96;
        valueTuple = sorting.three_way_partition(ints, 95, 0, 1, 94, 512);

        // test 40
        sorting = new Sorting();
        ints = new int[2];
        ints[0] = 1023;
        ints[1] = 1023;
        valueTuple = sorting.three_way_partition(ints, 1023, 0, 1, 1022, 1023);

        return;
    }

}